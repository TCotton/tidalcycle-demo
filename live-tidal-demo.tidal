cps (120/60/4)

-- drum patterns in do block

do
  let drumz1 = every 4 (|> sound "drum")
            $ sound "[drum <dr:2>] drum *2"
            # gain 0.6
            # orbit 0
  let drumz2 = sound "[drum <dr:1>] drum [drum <techno:5>] drum /2"
            # gain 0.5
            # orbit 1
  let drumz3 = sound "<techno:1> *4"
            # room 1.5
            # size 0.3
            # gain 0.7
            # orbit 2
  let drumz4 = sound "co"
            # gain 0.6
            # orbit 3
  let drumz5 = sound "[<techno:3> <techno:2>] *2"
            # shape "0 0.18"
            # gain 0.6
            # orbit 4
  d1 $ stack [drumz1, drumz2, drumz3, drumz4, drumz5] # crush 4 # delaytime (range 0.5 1.2) $ fast 4 sine # delayfeedback 0.6 # delaycutoff 1000 # delaymix 0.7 # delaypan (range (-1) 1 $ slow 2 sine)
   --  # krush 6 # shape 0.3 # room 1 # gain 0.7 # delaytime (range 1.2 0.5 $ fast 4 sine)

hush

d1 silence

-- Reproduction of piano intro

d2
  $ note "f e'min d'min c [10,14,17] a'min g'min f"
  # sound "<bass3:0>"
  # sustain 0.1
  # room 0.9
  # size 0.3
  # gain 0.6
  # orbit 5 -- routed to audiochannel 11-12

hush

d1 silence
-- vocal sample

d3 
  $ slow 4
  $ loopFirst
  $ chew 4 "0 1*2 2*2 [~ 2]"
  $ ghost' (1/4)
  $ sound "<vocals_c:2>"
  # gain 0.6
  # room 2.0
  # crush 4
  # ring 0.5
  # orbit 6 -- routed to audiochannel 13

solo 3

hush

unsolo 3

d1 silence

hush

-- piano sample

let spread1    = (spread ($) [jux rev, rev])
    spread2    = spread ($) [density 2, rev, slow 2, striate 3, (# speed "0.8")]
    juxrev     = jux rev
    revEffect  = rev
    palindrom  = palindrome
    in d4 $ stack [(
      slow 2
      $ spread2
      $ chop 32
      $ sound "piano_c"
      # gain 0.35
      # room 1.0
      # orbit 7
      )]

hush

d4 silence
--- haskel function signatures
--- # the same as the pipe operator |=| pipe equals pipe
